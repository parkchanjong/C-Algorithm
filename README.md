알고리즘 C++

## 정렬
- 정렬 스와핑
```
i = 기존 값
j = 바꾸려는 값
temp = 잠시 저장하는 공간
temp = array[i];
array[i] = array[j];
array[j] = temp;
```

### 선택 정렬
- 가장 작은 것을 선택해서 제일 앞으로 보내자
- 등차수열
- N * ( N + 1) / 2
- O(N^2)
- 비효율적

### 버블 정렬
- 앞에 있는 값과 비교해서 더 작은 값은 앞으로 보내자
- 한번 반복 했을때 가장 큰값이 끝으로 가게된다.
- 등차수열
- N * ( N + 1) / 2
- O(N^2)
- 비효율적
- 선택정렬 보다 느림  
- 자리가 바꾸는 연산이 많이 들어감

### 삽입 정렬
- 앞에 삽입할 위치를 찾아 보내자
- 등차수열
- N * ( N + 1) / 2
- O(N^2)
- 정렬이 많이 되어있는 경우에는 빠르다

### 퀵 정렬
- 분할정복 알고리즘 사용
- 피벗값을 기준으로 두집합으로 나눈다.
- 일반적으로 가장빠른 정렬 알고리즘이다.
- O(N*logN)
- 최악은 O(N^2)

### 정렬팁
- 데이터의 개수를 시간 복잡도에 대입해 보고 어떤 알고리즘을 사용할 것인지 판단한다.
- 데이터 개수가 100만 정도 넘어가면 N*logN 으로 풀어야 한다.


### 병합 정렬
- 반으로 나누고 합쳐서 정렬한다.
- O(N*logN) 보장
- 가로: N
- 세로: logN
- 정렬배열은 전역변수로 선언해준다.

### C++ STL sort()
- 정렬함수

### vector, pair
- vector안에 pair로 한쌍을 만들어 사용한다.

### 완전 이진 트리
- 데이터가 루트 노드부터 시작해서 자식 노드가 
  왼쪽 자식 노드, 오른쪽 자식 노드로 차근차근 들어가는 구조의 이진트리

### 힙구조
- 완전 이진 트리 기반
- 최대힙
  - 부모노드가 자식노드 보다 큰 힙

### 힙 정렬
- 힙 트리 구조를 이용한 정렬방법.
- O(N) (1/2N logN)
- 힙생성(Heapify Algorithm) 알고리즘 수행
- 한번의 힙생성 시간복잡도: O(logN)
- 추가적인 배열이 필요하지 않아 메모리 측면에서도 효율적이다.
